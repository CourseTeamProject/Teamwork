#5月7号
#棋子的定义与初始化
#signalchess.h

#ifndef SIGNALCHESS_H
#define SIGNALCHESS_H
#include <QPoint>

class SignalChess
{

public:
    SignalChess(){};
    SignalChess(QPoint pt,bool bChessColor);  //位置和颜色为参数的构造函数
    ~SignalChess(void){};

    bool operator==(const SignalChess &t1)const // "==" SignalChess 类等于的重构函数
    {
        return ((mChessPossition == t1.mChessPossition) && (mChessColor == t1.mChessColor));
    }

    QPoint mChessPossition; //位置座标

    bool mChessColor; //颜色

};

#endif // SIGNALCHESS_H

#5月8号
#自动播放背景音乐
 //添加音乐播放
    QMediaPlayer *player = new QMediaPlayer(this);
    player->setMedia(QUrl("qrc:/GEM.wav")); // 将路径替换为音乐文件的资源路径
    player->setVolume(50); // 设置音量（可选）


    //播放音乐
    player->play();
#5月9号
#实现自动循环播放背景音乐
    //添加音乐播放
    QMediaPlaylist *musicList = new QMediaPlaylist(this);  //添加音乐列表
    musicList->addMedia(QUrl("qrc:/music.wav")) ; //添加音乐列表
    QMediaPlayer *player = new QMediaPlayer(this);
    player->setPlaylist(musicList);  //设置音乐列表
    player->setVolume(10); // 设置音量（可选）

    //播放音乐
    player->play();
    musicList->setPlaybackMode(QMediaPlaylist::CurrentItemInLoop);  //循环播放
    //这样就可以单首音乐循环播放
#5月10号
#实现和棋功能
// 判断是否和棋
        if (IsDraw())
        {
            DeclareDraw();
        }
bool MainWindow::IsDraw() const
{
    // 判断是否还有空位置可下
    if (mPlayedChess.size() >= (CHESS_COLUMES+1) * (CHESS_ROWS+1))
        return true;

    // TODO: 还可以添加其他判断和棋的条件，如局面重复等
    // 这里只实现了棋盘满格的情况判断

    return false;
}

void MainWindow::DeclareDraw()
{
    QMessageBox::information(NULL, "GAME OVER", "和局", QMessageBox::Yes, QMessageBox::Yes);
    mPlayedChess.clear();
}
