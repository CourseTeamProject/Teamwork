#define CHESS_ROWS        15  //棋盘水平方向格子数
#define CHESS_COLUMES    15  //棋盘垂直方向格子数
#define RECT_WIDTH        50  //每个格子的宽
#define RECT_HEIGHT        50  //每个格式的高

void MainWindow::DrawChessboard()
{
    QPainter painter(this);
    painter.setRenderHint(QPainter::HighQualityAntialiasing, true); //渲染类型为高质量抗锯齿
    painter.setBrush(Qt::darkCyan);//设置填冲颜色
    painter.setPen(QPen(QColor(Qt::black),2));//设置画笔颜色,线粗,默认为实线

    for(int i = 0;i<CHESS_COLUMES; i++)//遍历每一个座标点,画出每一个矩形.
    {
        for (int j = 0; j<CHESS_ROWS; j++)
        {
            painter.drawRect( (i+1)*RECT_WIDTH,(j+1)*RECT_HEIGHT,RECT_WIDTH,RECT_HEIGHT);
        }
    }
}
void MainWindow::DrawChessWithMouse() //将要下的棋子,跟着鼠标移动
{
    QPainter painter(this);
    painter.setPen(QPen(QColor(Qt::transparent)));

    if (mIsBlackTurn)
    {
        painter.setBrush(Qt::black);
    }
    else
    {
        painter.setBrush(Qt::white);
    }

    //mapFromGlobal, 转换座标为相对座标
    QPoint cPoint(mapFromGlobal(QCursor::pos()));
    //只有在棋盘区域,才绘制圆跟随鼠标
    //qDebug()<<"cPoint.x()="<<cPoint.x()/RECT_WIDTH<<"cPoint.y()"<<cPoint.y()/RECT_WIDTH;

    if (! (cPoint.x()/RECT_WIDTH<1 || cPoint.x()/RECT_WIDTH>CHESS_COLUMES || cPoint.y()/RECT_HEIGHT<1 || cPoint.y()/RECT_HEIGHT>CHESS_ROWS))

       painter.drawEllipse(cPoint,RECT_WIDTH / 3,RECT_HEIGHT / 3);

}

for (int i = 0; i<mPlayedChess.size(); i++) //遍历已下棋子的座标
    {
        SignalChess signalchess = mPlayedChess[i];
        if (signalchess.mChessPossition == pt) //判定是否已存在棋子,若是,则放弃本次鼠标事件
        {
            return;
        }
    }
