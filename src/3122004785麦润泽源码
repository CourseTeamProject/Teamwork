void MainWindow::mousePressEvent(QMouseEvent * e) //鼠标按下事件
{
    //求鼠标点击处的棋子点pt
    QPoint pt;
    int x=e->pos().x() ;
    int y=e->pos().y();
    

    //判定鼠标的位置更接近哪一个座标点, 将该座标点作为要下棋子的点
    if (x%RECT_WIDTH<=RECT_WIDTH/2)

         pt.setX( x / RECT_WIDTH-1);
    else
        pt.setX( x / RECT_WIDTH);

    if (y%RECT_HEIGHT<=RECT_HEIGHT/2)

         pt.setY( y / RECT_HEIGHT-1);
    else
        pt.setY( y / RECT_HEIGHT);

    //qDebug()<<"x="<<x<<","<<"x%Rect_Width="<<x%RECT_WIDTH<<",pt.x="<<pt.x();
    //qDebug()<<"y="<<y<<","<<"y%Rect_height="<<x%RECT_HEIGHT<<",pt.y="<<pt.y();

 //如果已存在棋子，就什么也不做
    for (int i = 0; i<mPlayedChess.size(); i++) //遍历已下棋子的座标
    {
        SignalChess signalchess = mPlayedChess[i];
        if (signalchess.mChessPossition == pt) //判定是否已存在棋子,若是,则放弃本次鼠标事件
        {
            return;
        }
    }
    //不存在棋子，构造一个棋子,并添加到已下棋子容器中
    SignalChess signalchess(pt,mIsBlackTurn);
    mPlayedChess.append(signalchess);
 //统计4个方向是否五子连
    int nLeft =            CountNearChess(signalchess,QPoint(-1,0));
    int nLeftUp =        CountNearChess(signalchess,QPoint(-1,-1));
    int nUp =            CountNearChess(signalchess,QPoint(0,-1));
    int nRightUp =        CountNearChess(signalchess,QPoint(1,-1));
    int nRight =        CountNearChess(signalchess,QPoint(1,0));
    int nRightDown =    CountNearChess(signalchess,QPoint(1,1));
    int nDown =            CountNearChess(signalchess,QPoint(0,1));
    int nLeftDown =        CountNearChess(signalchess,QPoint(-1,1));
    if ( (nLeft + nRight) >= 4 ||
         (nLeftUp + nRightDown) >= 4 ||
         (nUp + nDown) >= 4 ||
         (nRightUp + nLeftDown) >= 4 )
    {
        QString str = mIsBlackTurn?"Black Win":"White Win";
        QMessageBox::information(NULL,  "GAME OVER",str, QMessageBox::Yes , QMessageBox::Yes);
        mPlayedChess.clear();
        //NewGame();
        return;
    }
    //换另一方下棋了
    mIsBlackTurn = !mIsBlackTurn;

}

int MainWindow::CountNearChess(SignalChess signalchess,QPoint ptDirection)
{
    int nCount = 0; //记录相连棋子个数
    SignalChess item=signalchess;
    item.mChessPossition += ptDirection;//产生待判定的座标

    while (mPlayedChess.contains(item)) //循环确认待判定的座标,item 和signalchess 只是座标位置不同,颜色相同
    {
        nCount++;
        item.mChessPossition += ptDirection; //产生下一个待判定的座标.
    }
    return nCount; //返回相连棋子个数
}

void MainWindow::StopGame() //停止棋局
{
    mPlayedChess.clear();  //清除已下棋子的容器
}

void MainWindow::RepentanceGame() //悔棋
{
    if (!mPlayedChess.empty())
    {
        mPlayedChess.pop_back(); //移除最后一个棋子
        mIsBlackTurn = !mIsBlackTurn; //变回上一个该下的棋子
    }
    else
      return;
}

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
     this->new_window =new MainWindow();
     connect(ui->pushButton,&QPushButton::clicked,this,[=](){
         this->hide();                                                  //隐藏widget页面
         this->new_window->show();                                      //显示五子棋页面
     });
     connect(ui->pushButton_2,&QPushButton::clicked,this,&Widget::close);//结束
}

//补充widget的头文件widget.h


#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include "mainwindow.h"
//五子棋界面为mainwindow界面，故在widget.h中包含这个头文件

QT_BEGIN_NAMESPACE
namespace Ui { class Widget; }
QT_END_NAMESPACE

class Widget : public QWidget
{
    Q_OBJECT

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

private:
    Ui::Widget *ui;
    MainWindow *new_window;
//在private处添加mainwindow指针变量new_window
};
#endif // WIDGET_H

